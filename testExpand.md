# `testExpand.html` 功能說明

這份文件旨在解釋 `testExpand.html` 的核心功能與實作方法。該 HTML 檔案建立了一個基於 Fabric.js 的網頁應用程式，讓使用者可以對上傳的圖片進行「外框擴展」或「裁切」，並將結果儲存為 PNG 檔案。

## 核心概念：邊距模型 (Padding Model)

此範例的核心並非傳統的「裁切框」，而是採用了一個更靈活的「邊距模型」。它透過四個屬性來控制圖片的顯示區域：

- `paddingT`: 頂部邊距
- `paddingB`: 底部邊距
- `paddingL`: 左側邊距
- `paddingR`: 右側邊距

這四個值決定了圖片原始邊界與物件最終邊界之間的距離。

- **正值邊距**：會在圖片周圍增加空白區域，實現「擴展外框」的效果。
- **負值邊距**：會將圖片的一部分裁切掉，實現「裁切」的效果。

這種模型的優點是邏輯統一，無論是擴展還是裁切，都是透過調整同一組 `padding` 值來完成。

## 程式碼結構分析

程式碼主要分為三個部分：

### 1. `fabric.EditableImage` (自訂 Fabric 物件)

這是整個應用的基礎。我們建立了一個繼承自 `fabric.Object` 的新類別，專門用來處理帶有邊距的圖片。

- **`initialize`**: 初始化物件，載入圖片元素並設定初始寬高。
- **`paddingT`, `paddingB`, `paddingL`, `paddingR`**: 物件的核心屬性，預設為 0。
- **`_render(ctx)`**:
    - **用途**：在 Canvas 上進行**互動式**繪製時被呼叫。
    - **行為**：
        1.  繪製一個**紅色背景**，其大小為物件的完整 `width` 和 `height`。這個紅色區域是個視覺輔助工具，方便開發者理解物件的實際邊界。
        2.  根據 `padding` 值計算來源圖片需要被「裁切」的區域 (`sx`, `sy`, `sWidth`, `sHeight`)。
        3.  計算裁切後的圖片應該被繪製在物件內的目標位置 (`dx`, `dy`)。
        4.  將計算好的圖片區域繪製到 Canvas 上。
- **`renderForExport(ctx)`**:
    - **用途**：當需要**匯出最終圖片**時被呼叫。
    - **行為**：此方法與 `_render` 非常相似，但有一個關鍵區別：它不會繪製紅色背景，而是使用**透明背景**。這確保了匯出的 PNG 檔案只包含擴展或裁切後的圖片，背景是透明的。

### 2. Canvas 與事件處理

這部分負責初始化 Fabric.js 的畫布，並處理使用者互動事件。

- **`imageLoader` (`change` 事件)**：
    1.  當使用者選擇一個檔案時觸發。
    2.  讀取圖片檔案。
    3.  建立一個 `EditableImage` 物件的實例。
    4.  將該物件加入畫布，並置中。
    5.  呼叫 `setupCustomControls()` 為此物件設定自訂的控制點。
- **`saveButton` (`click` 事件)**：
    1.  建立一個離屏 Canvas (`offscreenCanvas`)，其尺寸與 `EditableImage` 物件的目前尺寸相同。
    2.  呼叫物件的 `renderForExport()` 方法，將最終結果繪製到這個離屏 Canvas 上。
    3.  將離屏 Canvas 的內容轉換為 PNG 格式的 Data URL。
    4.  建立一個 `<a>` 標籤來觸發瀏覽器下載該圖片。

### 3. `setupCustomControls()` (自訂控制點邏輯)

這是實現互動式調整邊距的關鍵。此函式為傳入的物件設定了四個自訂的控制點，取代了 Fabric.js 預設的縮放和旋轉控制點。

- **控制點**：`mt` (上中), `mb` (下中), `ml` (左中), `mr` (右中)。
- **`renderStrip`**: 一個自訂的渲染函式，讓控制點顯示為長條形狀，更符合拖曳方向的直覺。
- **`actionHandler`**: 核心的拖曳處理邏輯。
    1.  當使用者拖曳任一控制點時，此函式會被觸發。
    2.  它會計算滑鼠的移動向量。
    3.  根據被拖曳的控制點（例如 `mt` 或 `ml`），更新 `EditableImage` 物件對應的 `padding` 值（例如 `paddingT` 或 `paddingL`）。
    4.  根據新的 `padding` 值，重新計算物件的總寬高 (`newWidth`, `newHeight`)。
    5.  最後，更新物件的 `width`, `height` 和 `left`, `top` 屬性，使物件在畫布上反映出新的尺寸和位置。

## 整體運作流程

1.  使用者透過檔案選擇器上傳一張圖片。
2.  程式建立一個 `EditableImage` 物件，並為其加上四個位於邊緣中央的自訂控制點。
3.  使用者拖曳其中一個控制點。
4.  `actionHandler` 捕捉到拖曳行為，並將其轉換為對 `padding` 值的修改。
5.  `padding` 值的改變觸發物件重新計算其總寬高和位置。
6.  `_render` 函式被呼叫，在畫布上即時更新顯示結果（包含紅色輔助背景）。
7.  使用者點擊「另存新檔」。
8.  `renderForExport` 函式在一個隱藏的 Canvas 上繪製最終結果（不含紅色背景）。
9.  隱藏 Canvas 的內容被轉換成 PNG 檔案並提供給使用者下載。
